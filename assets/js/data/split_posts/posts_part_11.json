[
  {
    "title": "ACM Template",
    "link": "https://tllwtg.top/2023/03/16/ACM-Template/",
    "pubDate": "Thu, 16 Mar 2023 13:00:00 +0000",
    "excerpt": "打个广告\n\n\ntLLWtG 的 ACM 算法模板库创建至今已有了长达半年的历史（），截止今天 2023.05.01 共收录了 45 种算法和结构的代码实现。模板库以如下表的标签进行分类：\n\n\n  \n    \n      Algorithm\n      Construction\n      Graph\n      Math\n      Others\n      Snippets\n    \n  \n\n\n这是托管于 GitHub 的仓库链接，之后还将不断添加新的模板。（其中部分来源于网络的代码已在注释中标注）\n\n\n  ACM-Template 遵循 MIT License。\n\n\n顺便贴个 CF 蓝名成就（",
    "tags": [
      "code",
      "cp"
    ],
    "author": "unknown-author",
    "source": "tLLWtG Blog"
  },
  {
    "title": "Strict Weak Ordering",
    "link": "https://tllwtg.top/2023/01/10/Ordering/",
    "pubDate": "Tue, 10 Jan 2023 20:00:00 +0000",
    "excerpt": "严格弱序是个大坑 : (\n\n\n一直想总结一下 STL 中众多内含比较关系的函数和容器所用到的 Strict Weak Ordering 原则，即严格弱序。正好今天刷到 luogu 的 P2123 皇后游戏，于是就顺手整理了相关内容。\n\n定义\n\n我们知道，STL 的任何一种内含比较关系的函数(sort, upper_bound…) 、容器(set, priority_queue…)都需要重载运算符或者自定义一个比较函数。而重载或者自定义的比较函数都需要遵循一个叫 Strict Weak Ordering 的原则，其定义如下：\n\nA Strict Weak Ordering is a Binary Predicate that compares two objects, returning true if the first precedes the second. This predicate must satisfy the standard mathematical definition of a strict weak ordering. The precise requirements are stated below, but what they roughly mean is that a Strict Weak Ordering has to behave the way that “less than” behaves: if a is less than b then b is not less than a, if a is less than b and b is less than c then a is less than c, and so on.\n\n\n  \n    Irreflexivity:\n\n    f(x, x) must be false.\n  \n  \n    Antisymmetry:\n\n    f(x, y) implies !f(y, x).\n  \n  \n    Transitivity:\n\n    f(x, y) and f(y, z) imply f(x, z).\n  \n  \n    Transitivity of incomparability:\n\n    If x is incomparable with y (meaning that neither f(x, y) nor f(y, x) is true) and if y is incomparable with z, then x is incomparable with z.\n  \n\n\n当我们用小于号 < 来表示严格弱序的比较规则，就可推出以下四条性质：\n\n\n  \n    非自反性\n\n    x !< x\n  \n  \n    非对称性\n\n    x < y ==> y !< x\n  \n  \n    传递性\n\n    x < y, y < z ==> x < z\n  \n  \n    不可比性的传递性\n\n    x !< y, y !< x, y !< z, z !< y ==> x !< z, z !< x\n  \n\n\n\n  这里的不可比可以简单理解成相等。但实际上 x 和 y 不一定相同(identical)，况且我们也没有定义 ==。\n\n\n应用\n\n以自定义类 fool 为例，重载其小于号，并自定义比较函数 cmp。\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nclass fool {\n  int num;\n\n  bool operator<(const fool &a) const {\n    return this.num < a.num;\n  }\n};\n\nbool cmp(const bool &x, const bool &y)\n{\n    return x.num < y.num;\n}\n\n\n也许有人要问了，如果只定义小于号 <，那程序怎么区分大于和等于呢？\n相等是酱紫判断的：!(x <= y) && !(x <= y)\n这里给出由小于号 < 推出的逻辑运算的表达式：\n\n<(a, b): (a < b) \n>(a, b): (b < a)\n==(a, b): !(a < b) && !(b < a)\n<=(a, b): !(b < a)\n>=(a, b): !(a < b)\n!=(a, b): (a < b) || (b < a)\n\n显而易见，上面的重载和 cmp 都符合严格弱序。但是当比较规则变得复杂的时候，我们就必须小心判断比较规则是否遵循了严格弱序的定义。下面以文章开头讲的 P2123 皇后游戏为例来谈谈如何处理复杂的比较规则。\n\n例题\n\nP2123 皇后游戏\n\n由题意，我们进行一番简单的数学推理，可以得到一个贪心式：min(ai, bj) < min(aj, bi)，假如你从未听过过严格弱序的概念，大概会直接写出这样的比较函数：\n1\n2\n3\n4\nbool cmp(const fool &x, const fool &y)\n{\n    return min(x.a, y.b) < min(x.b, y.a);\n}\n\n这样写有什么问题？\n由数学证明，显然(具体推理过程在这)\n我们发现这个比较规则仅仅满足非自反性、非对称性、传递性，而不满足不可比性的传递性。那我们要怎么使求得的贪心式遵循严格弱序呢？\n我们先按a与b的大小关系把所有数据分为三组：\n\n\n  当 ai < bi, aj < bj 时，ai <= aj 按 a 升序\n  当 ai == bi, aj == bj 时，whatever\n  当 ai > bi, aj > bj 时，bi >= bj 按 b 降序\n\n\n这里我们再引入一个符号函数 d = sgn(x) = sgn(a - b)\n\n于是得到最终的比较规则：先按 d 值排序，然后若 d 值小于等于 0，按 a 升序排序（这里把 2 组归入 1 组）；若 d 值大于 0，则按 b 降序排序。\n\n1\n2\n3\n4\nbool cmp(const fool &x, const fool &y)\n{\n    return (x.d != y.d ? x.d < y.d : (x.d <= 0 ? x.a < y.a : x.b > y.b));\n}\n\n\n这样对贪心式进行补充后，就满足了严格弱序。\n\n总结\n\n在把奇奇怪怪的式子用作比较规则之前，请先检查它是否符合严格弱序。",
    "tags": [
      "code",
      "cp"
    ],
    "author": "unknown-author",
    "source": "tLLWtG Blog"
  },
  {
    "title": "Snippet: simple Unity comment component",
    "link": "https://tryfinally.dev/unity-comment-component",
    "pubDate": "Sun, 14 May 2023 00:00:00 +0000",
    "excerpt": "I put this together a while ago. Maybe you’ll find it useful.\n\nOverview\n\n\n\n\n\n  Single script, plug-and-play.\n  Double-click the text area to edit.\n\n\nInstallation\n\nEither paste the script below into your project, or install it as a package via the Unity Package Manager using this URL:0\n\n\nhttps://gist.github.com/19c183d115953f26c62cbdced7fab5a2.git\n\n\nSource\n\n\nView source on gist.github.com\n\nOptimization\n\n\n  During build, the [PostProcessScene] callback removes instances of the component from your scenes.\n  Since we can’t remove the entire component from prefabs at build time1, the ISerializationCallbackReceiver callback clears the comment content.\n  You can even use it with ECS since the component won’t be baked at all.\n\n\n\n  \n    \n      Yes, you can install packages straight from GitHub Gists (if they’re set up with a package.json and an .asmdef). I’m as surprised as you are that this actually works, but Gists are built on top of regular Git repositories, so it makes sense. return ︿\n    \n    \n      I looked, but couldn’t find any way to do this. If I recall correctly, deleting the component during serialization results in an error. I wish we had [PostProcessPrefab] or something… return ︿",
    "tags": [
      "unity",
      "unityprotips"
    ],
    "author": "unknown-author",
    "source": "tryfinally"
  },
  {
    "title": "Snippet: C# version of `SquirrelNoise5`",
    "link": "https://tryfinally.dev/squirrel-noise-5-ported-to-csharp",
    "pubDate": "Fri, 12 May 2023 00:00:00 +0000",
    "excerpt": "TL;DR these functions return random-looking numbers based on an integer position and seed. And they’re super fast.\nYou can use these for procedural generation, or for anything else that needs a bit of (stateless and reproducible) randomness.\n\nBackground\n\nOriginal C++ code published here by Squirrel Eiserloh.\nI changed the API a little, grouping the functions by return type - hope you don’t mind.\n\nRecommended talks by the author:\n\n  Math for Game Programmers: Noise-Based RNG\n  Math for Game Programmers: Fast and Funky 1D Nonlinear Transformations\n  Math for Game Programmers: Juicing Your Cameras With Math\n  Math for Game Programmers: Randomness in Games\n\n\nInstallation\n\nEither simply paste the class below into your project, or install it as a package via the Unity Package Manager using this URL:0\n\n\nhttps://gist.github.com/eb733523bee790c3b15e9aac39713ef8.git\n\n\nSource\n\n\nView source on gist.github.com\n\n  \n    \n      Yes, you can install packages straight from GitHub Gists (if they’re set up with a package.json and an .asmdef). I’m as surprised as you are that this actually works, but Gists are built on top of regular Git repositories, so it makes sense. return ︿",
    "tags": [
      "unity",
      "csharp"
    ],
    "author": "unknown-author",
    "source": "tryfinally"
  },
  {
    "title": "Snippet: Wider ChatGPT conversation window",
    "link": "https://tryfinally.dev/chatgpt-wide-userstyle-theme",
    "pubDate": "Wed, 10 May 2023 00:00:00 +0000",
    "excerpt": "It’s a quick, simple, no-nonsense browser UserScript that makes your ChatGPT conversation wider.\nI can’t be the only one who needed this.\n\nLooks like this\n\n\n\nSource\n\n\nView source on gist.github.com\n\nInstallation\n\nStylus (and other UserStyle managers)\n\nCopy the .css snippet and paste it into Stylus or some other UserStyle manager of choice.\nYou can also install it directly from userstyles.world.\n\nTamperMonkey (and other UserScript managers)\nTo install via TamperMonkey, simply click here.\nOtherwise, you can paste the .user.js snippet above into a new script in your favorite UserScript manager.\n\nOther tips\n\n\n  The Enable chat history button is pretty much purposefully designed to trick you into accidentally clicking it. To hide it, append this to the injected stylesheet: .w-full.mt-4.btn-primary.relative.btn:has(svg) { display: none; }\n  You can install the website “as an app” in browsers such as Edge, Chrome and Brave. This will let you easily access it from your system menu and run it separately from your browser.\n  I’ll try to keep this code updated as the site layout changes.\n\n\nEnjoy!",
    "tags": [
      "chatgpt"
    ],
    "author": "unknown-author",
    "source": "tryfinally"
  },
  {
    "title": "Pump Up The Volume: Writing custom Volume Components in Unity",
    "link": "https://tryfinally.dev/unity-custom-srp-volume-components",
    "pubDate": "Sat, 06 May 2023 00:00:00 +0000",
    "excerpt": "What are Volume Components?\n\nVolume Components are a way to extend the functionality of Unity’s Volume Framework. They can be used with both the High Definition Render Pipeline (HDRP) and the Universal Render Pipeline (URP), as well as in custom Scriptable Render Pipelines (SRP).\n\n\n  HDRP documentation\n  URP documentation\n\n\nYou can create custom Volume Components to find a blended set of parameters determined by the camera’s position within the scene.\nThey’re great for post-effects but can sometimes be useful for other purposes - even game mechanics.\n\n\n  Creating a Volume Component    \n      1. Create a new script        \n          Inheriting from VolumeComponent\n          Inheriting from CustomPostProcessVolumeComponent (HDRP)\n        \n      \n      2. Add parameter fields\n      3. Use the volume component        \n          Based on VolumeComponent            \n              HDRP\n              URP\n            \n          \n          Based on VolumeComponent with a custom updater script\n          Based on CustomPostProcessVolumeComponent (HDRP)\n        \n      \n    \n  \n  Usage ideas    \n      Global shader properties\n      Camera modifiers\n      Directional light\n      Time control\n      Other gameplay-related ideas\n    \n  \n\n\nCreating a Volume Component\n\n1. Create a new script\n\nInheriting from VolumeComponent\n\nStart by creating a new script that inherits from the VolumeComponent class, which provides the necessary functionality to integrate with the volume framework.\n\n0\n1\n2\n3\n4\n[VolumeComponentMenu(\"tryfinally.dev/\" + nameof(MyPostProcessVolumeComponent))]\npublic sealed class MyVolumeComponent : VolumeComponent\n{\n    // your volume parameters go here\n}\n\n\nInheriting from CustomPostProcessVolumeComponent (HDRP)\n\nIn HDRP, you can instead inherit from CustomPostProcessVolumeComponent if you want to create a post-processing effect. This base class requires you to implement the void Render method, which is called by the volume framework when the volume is rendered. This lets us easily write a post-processing effect in a single class.\n\nImplementing the IPostProcessComponent interface is not optional for some reason, so don’t skip it. It lets you control whether the post process should be rendered or not via the bool IPostProcessComponent.IsActive() method.\n\nRead more about this workflow in the Creating a Custom Post-Process Effect docs page.\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n[VolumeComponentMenu(\"tryfinally.dev/\" + nameof(MyPostProcessVolumeComponent))]\npublic sealed class MyPostProcessVolumeComponent : CustomPostProcessVolumeComponent, IPostProcessComponent\n{\n    // your volume parameters go here\n\n    /// <summary> Injection point of the custom post process in HDRP. </summary>\n    public override CustomPostProcessInjectionPoint injectionPoint\n        => CustomPostProcessInjectionPoint.AfterPostProcess;\n\n    /// <summary> Tells if the post process needs to be rendered or not. </summary>\n    bool IPostProcessComponent.IsActive() => true; // you can use volume parameters to control this\n\n    /// <summary> Setup function, called once before render is called. </summary>\n    public override void Setup() { }\n\n    /// <summary> Cleanup function, called when the render pipeline is disposed. </summary>\n    public override void Cleanup() { }\n\n    /// <summary>\n    /// Called every frame for each camera when the post process needs to be rendered.\n    /// </summary>\n    /// <param name=\"cmd\">Command Buffer used to issue your commands</param>\n    /// <param name=\"camera\">Current Camera</param>\n    /// <param name=\"source\">Source Render Target, it contains the camera color buffer in it's current state</param>\n    /// <param name=\"destination\">Destination Render Target</param>\n    public override void Render(CommandBuffer cmd, HDCamera camera, RTHandle source, RTHandle destination, RTHandle depthTexture)\n        => cmd.Blit(source, destination); // (copy source to destination without any changes - your post process implementation goes here)\n}\n\n\n2. Add parameter fields\n\nThe volume framework offers a set of built-in parameter types for use in the editor. These give you a nice editor UI for your parameters and lets you use the volume framework’s interpolation/override system.\n\n\n  Make sure to always initialize the parameters using new().\nDo not rely on the serialization system to do this for you - Unity creates volume profile instances at runtime, and your fields will be null unless you explicitly initialize. (You’ll want to do this to define the default value and the allowed value range anyway.)\n\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n// floats\npublic FloatParameter MyFloat = new(value: 0f);\npublic ClampedFloatParameter MyClampedFloat = new(value: 0, min: -1, max: +1);\npublic MinFloatParameter MyMinFloat = new(value: 0, min: 0);\npublic MaxFloatParameter MyMaxFloat = new(value: 0, max: 0);\n\n// ints\npublic IntParameter MyInt = new(value: 0);\npublic ClampedIntParameter MyClampedInt = new(value: 0, min: -1, max: +1);\npublic MinIntParameter MyMinInt = new(value: 0, min: 0);\npublic MaxIntParameter MyMaxInt = new(value: 0, max: 0);\n\n// other common primitives/structs\npublic BoolParameter MyBool = new(value: false);\npublic Vector2Parameter MyVector2 = new(value: Vector2.zero);\npublic Vector3Parameter MyVector3 = new(value: Vector3.zero);\npublic Vector4Parameter MyVector4 = new(value: Vector4.zero);\npublic ColorParameter MyColor = new(value: Color.white);\npublic LayerMaskParameter MyLayerMask = new(value: 0);\npublic AnimationCurveParameter MyAnimationCurve = new(value: null);\n\n// nointerp variants - these simply take the value from the volume with highest weight instead of interpolating\n// (roughly equivalent to using VolumeParameter<T> directly)\npublic NoInterpFloatParameter MyNoInterpFloat = new(value: 0f);\npublic NoInterpClampedFloatParameter MyNoInterpClampedFloat = new(value: 0, min: -1, max: +1);\npublic NoInterpMinFloatParameter MyNoInterpMinFloat = new(value: 0, min: 0);\npublic NoInterpMaxFloatParameter MyNoInterpMaxFloat = new(value: 0, max: 0);\npublic NoInterpIntParameter MyNoInterpInt = new(value: 0);\npublic NoInterpClampedIntParameter MyNoInterpClampedInt = new(value: 0, min: -1, max: +1);\npublic NoInterpMinIntParameter MyNoInterpMinInt = new(value: 0, min: 0);\npublic NoInterpMaxIntParameter MyNoInterpMaxInt = new(value: 0, max: 0);\npublic NoInterpVector2Parameter MyNoInterpVector2 = new(value: Vector2.zero);\npublic NoInterpVector3Parameter MyNoInterpVector3 = new(value: Vector3.zero);\npublic NoInterpVector4Parameter MyNoInterpVector4 = new(value: Vector4.zero);\npublic NoInterpColorParameter MyNoInterpColor = new(value: Color.white);\n\n// unity objects. these don't support interpolation\n// (currently, at least - judging by the TODOs in code, this may change in the future)\npublic TextureParameter MyTexture = new(value: null);\npublic Texture2DParameter MyTexture2D = new(value: null);\npublic Texture3DParameter MyTexture3D = new(value: null);\npublic RenderTextureParameter MyRenderTexture = new(value: null);\npublic CubemapParameter MyCubemap = new(value: null);\n\n\nYou can easily make your own reusable parameter types by inheriting from the VolumeParameter<T> class.\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n[Serializable, VolumeComponentMenu(\"tryfinally.dev/\" + nameof(float3))]\npublic sealed class Float3Parameter : VolumeParameter<float3>\n{\n    public Float3Parameter(float3 value, bool overrideState = false)\n        : base(value, overrideState) { }\n\n    /// <summary> Defines the interpolation function to use when blending between values. </summary>\n    /// <param name=\"from\">The value to interpolate from.</param>\n    /// <param name=\"to\">The value to interpolate to.</param>\n    /// <param name=\"t\">The interpolation factor.</param>\n    public override void Interp(float3 from, float3 to, float t)\n        => math.lerp(from, to, t);\n}\n\n\nHowever, if you just to define a quick non-interpolated parameter for some simple type, you can use the VolumeParameter<T> class directly:\n\n0\n1\npublic VolumeParameter<LightLayerEnum> LightLayers\n    = new() { value = LightLayerEnum.LightLayerDefault };\n\n\n3. Use the volume component\n\nTo use volume components, you need to set up a volume profile and add it to your scene.\nYou can do this by creating a new volume profile asset, and adding it to your scene via the Volume component.\nSome volume components are convenient to set up globally, while others are more useful when they affect only a specific area of the scene.\n\nIn either case, the volume framework calculates a single interpolated volume component for each camera in the scene.\n\nBased on VolumeComponent\n\nHDRP\n\nThe simplest option is to grab the volume component from the camera and use your parameters in another script like so:\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n// get the volume component for main camera\n// (this returns a runtime instance of the volume component that already contains interpolated values)\nvar component = HDCamera\n    .GetOrCreate(Camera.main)\n    .volumeStack\n    .GetComponent<MyVolumeComponent>();\n\n// do something with the parameter values\nDebug.Log(component.MyFloat.value);\n\n\nURP\n\nThe Universal Render Pipeline has a slightly different API for accessing the volume stack:\n\n0\n1\n2\n3\nvar component = camera\n    .GetComponent<UniversalAdditionalCameraData>()\n    .volumeStack\n    .GetComponent<MyVolumeComponent>();\n\n\nBased on VolumeComponent with a custom updater script\n\nThe above option is moderately convenient in the long run, so I wrote a quick helper script that updates all volume components. All you have to do is implement the convenient IUpdatableVolumeComponent interface. Subsequent examples will use this approach for brevity.\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\nusing System;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Rendering;\nusing static System.Reflection.BindingFlags;\n\n/// <summary> An interface for volume components that can be updated. </summary>\ninterface IUpdatableVolumeComponent\n{\n    /// <summary> Called every frame to update the volume component. </summary>\n    void Update();\n    \n    /// <summary> Indicates whether the component should be updated in edit mode. </summary>\n    bool ExecuteInEditMode => true;\n}\n\n/// <summary>\n/// Updates volume components that implement <see cref=\"IUpdatableVolumeComponent\"/>.\n/// Make sure there's a single instance of this component somewhere in the scene, eg. on the main camera.\n/// </summary>\n[ExecuteAlways]\npublic sealed class VolumeComponentUpdater : MonoBehaviour\n{\n    VolumeStack previousStack;\n    Dictionary<Type, VolumeComponent> cachedVolumeStackComponents;\n\n    void LateUpdate() // executes after gameplay/animation update, but before rendering\n    {\n        // this is fast now!\n        // https://blog.unity.com/technology/new-performance-improvements-in-unity-2020-2\n        var camera = Camera.main;\n\n        if (!camera)\n            return;\n\n        // in HDRP, get the VolumeStack from the HDCamera associated with the main camera\n        var stack = UnityEngine.Rendering.HighDefinition.HDCamera\n            .GetOrCreate(camera)\n            .volumeStack;\n            \n        // in URP, obtain the VolumeStack from the UniversalAdditionalCameraData instead\n        /*\n        var stack = camera\n            .GetComponent<UnityEngine.Rendering.Universal.UniversalAdditionalCameraData>()\n            .volumeStack;\n        */\n\n        if (stack == null)\n            return;\n\n        // invalidate cache if stack changed\n        if (stack != previousStack)\n            cachedVolumeStackComponents = null;\n\n        previousStack = stack;\n\n        // get components from the VolumeStack using reflection because the API is private :(\n        // we cache the result to avoid doing this every frame\n        // (note: this is not future-proof and is likely to break in future versions of Unity)\n        cachedVolumeStackComponents ??= typeof(VolumeStack)\n            .GetField(\"components\", NonPublic | Instance)\n            .GetValue(stack) as Dictionary<Type, VolumeComponent>;\n\n        // update components that implement IUpdatableVolumeComponent\n        foreach (var component in cachedVolumeStackComponents.Values)\n            if (component is IUpdatableVolumeComponent updatable)\n                if (updatable.ExecuteInEditMode || Application.isPlaying)\n                    updatable.Update();\n    }\n}\n\n\nBased on CustomPostProcessVolumeComponent (HDRP)\n\nIf you’re using the CustomPostProcessVolumeComponent base class, you just set it up in your HDRP Global Settings, configure your volume, and your effect should be rendered automatically.\nHowever, this is not very performant if you’re not actually doing any post-process rendering, because the void Render method requires you to at least copy the source texture to the destination.\n\nUsage ideas\n\nAlthough post-processing effects are awesome, they merely scratch the surface of what’s possible with volume components.\nI’ve found that in practice, in many projects it can be very convenient to control some (global or per-camera) runtime values based on the camera position. Here’s some examples.\n\nGlobal shader properties\n\nThis is probably the most common use case.\nYou can use a volume component to set global shader property values.\nFor example, you can use it to set wind direction and strength for your vegetation shaders.\nOr you could use volumes to create biomes and use a volume component to locally set the shader property values for each biome (vegetation color, wind strength, weather settings, etc).\nYou easily can change/animate the values at runtime by adjusting volume weights.\n\n\n  This is super convenient for escaping material hell!!\nYou can use the same shader and material for all your objects, and tweak their look in each scene separately via global volumes.\n\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n/// <summary> A volume component for setting global shader properties. </summary>\n[VolumeComponentMenu(\"tryfinally.dev/\" + nameof(GlobalShaderPropertiesVolumeComponent))]\npublic sealed class GlobalShaderPropertiesVolumeComponent : VolumeComponent, IUpdatableVolumeComponent\n{\n    public ColorParameter VegetationColor = new(value: Color.green);\n    public ClampedFloatParameter RainStrength = new(value: 0f, min: 0f, max: 1f);\n    public ClampedFloatParameter SnowAmount = new(value: 0f, min: 0f, max: 1f);\n    public FloatParameter WindStrength = new(value: 0f);\n    public Vector3Parameter WindDirection = new(value: Vector3.zero);\n\n    void IUpdatableVolumeComponent.Update()\n    {\n        Shader.SetGlobalColor(\"_VegetationColor\", VegetationColor.value);\n        Shader.SetGlobalFloat(\"_RainStrength\", RainStrength.value);\n        Shader.SetGlobalFloat(\"_SnowAmount\", SnowAmount.value);\n        Shader.SetGlobalFloat(\"_WindStrength\", WindStrength.value);\n        Shader.SetGlobalVector(\"_WindDirection\", WindDirection.value.normalized);\n    }\n}\n\n\nCamera modifiers\n\n(This example uses Cinemachine, but you can use any camera system you like.)\n\nYou can use volume components to modify the behaviour of your Cinemachine cameras.\nFor example, you can create a volume component that modifies the camera’s field of view based on the camera’s position in the scene.\nThis way, you can make the camera zoom in when the player is in a tight space, or zoom out when the player is in an open area.\nIt’s possible that you already have volumes in your scene that you can reuse for this purpose.\n\nThis component only stores the field of view value,   and the actual modification is done in a Cinemachine extension.\n\n0\n1\n2\n3\n4\n5\n6\n7\n/// <summary> A volume component that drives modifications to the state of a cinemachine camera. </summary>\n[VolumeComponentMenu(\"tryfinally.dev/\" + nameof(CinemachineModifierVolumeComponent))]\npublic sealed class CinemachineModifierVolumeComponent : VolumeComponent\n{\n    [Tooltip(\"The FoV offset to apply to the camera\")]\n    public ClampedFloatParameter FieldOfView\n        = new(value: 0, min: -30, max: +30);\n}\n\n\nIn this example, we use the PostPipelineStageCallback to modify the FOV in the final stage of the pipeline.\n\n\n  Cinemachine adopts a semi-functional technique, recomputing the camera state for each frame according to the camera pipeline.\nExtensions can intervene at different stages of the pipeline to alter the camera state calculation.\nFinally, the CinemachineBrain applies the result state to the UnityEngine.Camera responsible for rendering.\n\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n/// <summary>\n/// Modifies the field of view of a cinemachine camera.\n/// Add this component to your virtual camera to affect it via the volume framework.\n/// See: https://docs.unity3d.com/Packages/com.unity.cinemachine@2.9/manual/CinemachineVirtualCameraExtensions.html\n/// </summary>\npublic sealed class CinemachineModifierExtension : CinemachineExtension\n{\n    protected override void PostPipelineStageCallback(\n        CinemachineVirtualCameraBase vcam, // the virtual camera this extension belongs to\n        CinemachineCore.Stage stage,       // the current pipeline stage\n        ref CameraState state,             // the current camera state\n        float deltaTime)\n    {\n        // apply modifications in last stage after other camera properties have been calculated\n        // (you might want to use an earlier stage if you want to modify other parameters, eg. camera position)\n        if (stage is not CinemachineCore.Stage.Noise)\n            return;\n\n        // get the interpolated volume component from the volume stack \n        var component = HDCamera\n            .GetOrCreate(Camera.main)\n            .volumeStack\n            .GetComponent<CinemachineModifierVolumeComponent>();\n\n        // the camera state is recalculated from scratch every frame by the Cinemachine pipeline,\n        // so we can safely apply the offset directly\n        state.Lens.FieldOfView += component.FieldOfView.value;\n    }\n}\n\n\nIdeas for other camera parameters that can be useful to control via volumes:\n\n  Lens settings (e.g. focal length, aperture, focus distance, etc)\n  Noise/shake settings\n  Position and rotation offset\n\n\nDirectional light\n\nYou can use a volume component to spawn and control a sun in your scene.\nHandling the sun as a scene object can be cumbersome.\nSince many settings are in volume profiles, it’s helpful to put sun settings there too.\nThis makes it easy to share lighting between scenes, switch between sun options, and keep changes when leaving play mode.\n\n\n  Usually you’ll want to define a global volume so that the sun is constant throughout the scene, but you can also use a local volume to modify the light parameters in a specific area.0\nThis example is HDRP-specific, but you should be able to adapt it to URP with little problem.\n\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\nusing UnityEngine;\nusing UnityEngine.Rendering;\nusing UnityEngine.Rendering.HighDefinition;\n\n/// <summary> A volume component for spawning and controlling a sun in the scene. </summary>\n[VolumeComponentMenu(\"tryfinally.dev/\" + nameof(SunVolumeComponent))]\npublic sealed class SunVolumeComponent : VolumeComponent, IUpdatableVolumeComponent\n{\n    [Tooltip(\"The light layers the light should affect\")]\n    public VolumeParameter<LightLayerEnum> LightLayers = new() { value = LightLayerEnum.LightLayerDefault };\n\n    [Tooltip(\"The intensity of the sun\")]\n    public ClampedFloatParameter Intensity = new(value: 80_000, min: 0, max: 150_000);\n\n    [Tooltip(\"The temperature of the sun (in Kelvin)\")]\n    public ClampedFloatParameter Temperature = new(value: 6_500, min: 1_000, max: 20_000);\n\n    [Tooltip(\"The color of the sun\")]\n    public ColorParameter Color = new(value: UnityEngine.Color.white);\n\n    [Tooltip(\"The direction of the sun (euler angles)\")]\n    public Vector2Parameter Direction = new(value: new(45, 45)); // could use better interpolation\n\n    [Tooltip(\"Angular diameter of the sun as seen from the camera (in degrees)\")]\n    public ClampedFloatParameter AngularDiameter = new(value: 0.5f, min: 0, max: 4);\n    \n    [Tooltip(\"The multiplier for volumetric lighting\")]\n    public ClampedFloatParameter VolumetricDimmer = new(value: 1, min: 0, max: 16);\n\n    [Tooltip(\"The shadow resolution quality level of the sun\")]\n    public ClampedIntParameter ShadowResolution = new(value: 3, min: 0, max: 3);\n    \n    [Tooltip(\"Whether or not to use contact shadows\")]\n    public BoolParameter ContactShadows = new(value: true);\n\n    GameObject gameObject;\n    Light light;\n    HDAdditionalLightData hdlight;\n\n    void IUpdatableVolumeComponent.Update()\n    {\n        if (!gameObject)\n        {\n            gameObject = new(\"Sun\") { hideFlags = HideFlags.DontSave | HideFlags.NotEditable };\n            light = gameObject.AddComponent<Light>();\n            hdlight = gameObject.AddComponent<HDAdditionalLightData>();\n\n            hdlight.EnableShadows(true);\n            hdlight.SetLightTypeAndShape(HDLightTypeAndShape.Directional);\n            hdlight.shadowUpdateMode = ShadowUpdateMode.EveryFrame;\n        }\n\n        gameObject.transform.rotation = Quaternion.Euler(Direction.value);\n        light.colorTemperature = Temperature.value;\n        hdlight.lightlayersMask = LightLayers.value;\n        hdlight.SetShadowResolutionOverride(false);\n        hdlight.SetShadowResolutionLevel(ShadowResolution.value);\n        hdlight.EnableColorTemperature(Temperature.overrideState);\n        hdlight.color = Color.value;\n        hdlight.intensity = Intensity.value;\n        hdlight.volumetricDimmer = VolumetricDimmer.value;\n        hdlight.angularDiameter = AngularDiameter.value;\n        hdlight.useContactShadow.useOverride = true;\n        hdlight.useContactShadow.@override = ContactShadows.value;\n    }\n\n    protected override void OnDisable()\n    {\n        base.OnDisable();\n        CoreUtils.Destroy(gameObject);\n    }\n}\n\n\nTime control\n\nUsing a volume component, you can create a slow-motion effect that slows down the game when the camera is within a specific area.\nThis would make most sense in an FPS game (like most gameplay-related ideas in this article).\n\nIs this useful? Is this crazy? No idea, but it’s a fun example so let’s do it anyway.1\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n/// <summary> A volume component for modifying the time scale of the game. </summary>\n[VolumeComponentMenu(\"tryfinally.dev/\" + nameof(TimeScaleVolumeComponent))]\npublic sealed class TimeScaleVolumeComponent : VolumeComponent, IUpdatableVolumeComponent\n{\n    [Tooltip(\"The time scale to apply to the game\")]\n    public ClampedFloatParameter TimeScale\n        = new(value: 1f, min: 0, max: 2); // important: the default value is applied when outside of all volumes\n\n    void IUpdatableVolumeComponent.Update()\n        => Time.timeScale = TimeScale.value;\n        \n    bool IUpdatableVolumeComponent.ExecuteInEditMode\n        => false;\n}\n\n\nOther gameplay-related ideas\n\n\n  You can use a volume component to set audio settings.\n    \n      Play FMOD snapshots and modify their weights based on the camera position.\n      Play different music and ambience based on the camera position.\n      Adjust global sound parameters, eg. reverb.\n    \n  \n  You can change gravity (and other gameplay parameters) based on the camera’s position in the scene.\n  You can change graphics settings based on the camera’s position in the scene, to optimize performance in certain areas.\n\n\n  \n    \n      Don’t laugh. Make your game for long enough and you’ll need this hack eventually. return ︿\n    \n    \n      Just make sure your camera’s position is not determined in a time-scale dependent way! This could lead to some weird behaviour (eg. the camera will get stuck when the time scale is 0). return ︿",
    "tags": [
      "unity",
      "csharp",
      "hdrp",
      "urp",
      "unityprotips"
    ],
    "author": "unknown-author",
    "source": "tryfinally"
  },
  {
    "title": "Obsidian으로 마크다운 글 써서 GitHub 블로그에 올리기",
    "link": "https://blog.potados.com/writings/obsidian-for-github-blog/",
    "pubDate": "Mon, 24 Jul 2023 01:05:52 +0900",
    "excerpt": "글쓰기가 영 귀찮습니다\n\n블로그에 뭐라도 써서 올리고 싶은데, 생각은 많은데 글 쓰려고 누워있다 벌떡 일어나려니 너무 귀찮은 겁니다. 웹 에디터 같은 것이 있다면 누워서 폰으로 뭐라도 끄적일 수가 있을텐데, 여기 GitHub 블로그에 올리려니 git 사용이 가능한 마크다운 에디터가 필요한 겁니다. 그래서 아이디어는 있는데 너무 귀찮아서 좌절되는 일이 많았습니다.\n\nObsidian?\n\n그러던 와중에 동료 개발자분을 통해 Obsidian이라는 물건을 발견했습니다. 마크다운 문서에 최적화된 노트 앱입니다.\n\nObsidian vs Notion\n\nObsidian과 비슷한 포지션(?)의 앱으로 Notion이 있겠습니다. 물론 기능은 Notion에 훨씬 많긴 하지만, 크로스 플랫폼으로 마크다운 또는 마크다운-스러운 문서를 편집 가능하다는 점에서 비슷하다고 생각해서 적어 봅니다.\n\n파일 기반\n\nObsidian은 사용자가 접근 가능한 파일을 대상으로 편집을 도와주는 에디터입니다. Vault라는 개념이 있긴 한데, 그냥 IDE의 워크스페이스 같은 느낌으로, 편집할 프로젝트 폴더를 지정하는 것에 가깝습니다. 반면 Notion에는 딱히 파일이나 폴더와 같은 개념이 없습니다. 따라서 md 파일을 기반으로 관리하는 GitHub 블로그를 위해 사용하기에는 조금 안 맞는 부분이 있습니다.\n\n기능\n\n기능의 범위로만 따지면 단순 문서 작성부터 DB 관리까지 못 하는게 없는 Notion에 비해 Obsidian은 조금 부족해 보이긴 합니다. 대신에 Notion이 지원하지 않는 마크다운 편집 기능이 매우 출중합니다. 가령 클립보드에 있는 링크를 붙여 넣으면 자동으로 마크다운 링크 첨부로 바꾸어 준다든가, (아래에서 후술할) 사진을 붙여 넣으면 자동으로 웹에 업로드하여 링크로 붙여 넣어주는 플러그인을 활용할 수 있는 점들이 좋습니다.\n\n플러그인\n\nNotion은 꾸준한 업데이트를 통해 외부 연동을 추가해주고 있지만, 원하는 기능이 없으면 생길 때까지 기다려야 합니다. Obsidian에서는 없는 기능은 커뮤니티 플러그인으로 대체할 수 있습니다. 지금도 git 플러그인과 이미지 업로드 플러그인을 사용하고 있습니다. 커뮤니티 플러그인도 없으면 템플릿을 기반으로 직접 만들어 배포할 수도 있습니다.\n\n퍼포먼스\n\nNotion은 느립니다. 특히 쓰면 쓸수록 느려집니다. Obsidian은 그에 비해 비교적 쾌적한 느낌입니다. 물론 아직 많은 양의 문서를 다루고 있지는 않아 지금 단언하긴 어렵겠지만, 적어도 문서를 편집하면서 퍼포먼스에 대해 불만이 생긴 적은 없었습니다.\n\niOS(& iPad OS)에서 200% 활용중입니다.\n\nAtom을 쓰다가 Obsidian으로 넘어오기로 결심한 것은 iOS 지원 때문입니다. Obsidian은 iOS에서 구동되고, 대부분의 기능이 그대로 지원됩니다. iOS에서 사용할 수 있으면, 언제 어디서든 글을 편집할 수 있는 겁니다. 누워서도 말이죠. 야호!\n\nObsidian은 파일 기반 에디터이기 때문에, 수정할 파일이 들어 있는 git 저장소를 로컬에 가져다 놓아야 합니다. iOS에서는 Working Copy를 사용해 git 저장소를 관리할 수 있습니다. 아이디어는 간단합니다. Working Copy로 가져온 git 저장소를 Obsidian으로 편집하는 겁니다.\n\n그런데 여기에 iCloud를 더하면\n\nObsidian의 vault를 iCloud Drive 안에다가 두면 자동으로 동기화 기능이 생겨버립니다. 이렇게 되면 Mac과 iOS 기기들 모두에서 편집과 동기화가 가능해집니다. 이렇게 여러 기기에서 편집된 git 저장소를 아무 기기에서나 열고 들어가 commit하고 올리면 바로 글이 발행됩니다. 이런 식의 흐름이 가능해지는 것입니다:\n\n\n  누워서 아이폰으로 새 글 템플릿 생성\n  앉아서 아이패드로 초고 작성\n  변경 사항이 자동으로 모두 동기화된 아이폰에서 Working Copy로 commit & push\n\n\n즉, 기기를 가리지 않고 하나의 로컬 저장소에 접근하는 것과 같습니다. 기기마다 git을 통해 수동으로 버전을 관리해야 하는 것에 비해 몹시 편할 뿐만 아니라, pull을 잊어버리고 있다가 conflict가 나는 것도 원천 차단할 수 있습니다.\n\n설정도 동기화 돼요\n\nObsidian의 설정은 vault 내의 .obsidian 폴더에 저장됩니다. 따라서 vault가 동기화된다면 에디터의 설정과 템플릿, 플러그인을 비롯한 구성이 모두 동기화되는 것입니다.\n\n블루투스 키보드와 최적의 조합\n\n여기에 블루투스 빨콩 키보드를 얹으면 가히 극강의 생산성이 발휘됩니다. 네이티브 에디터 + iCloud 동기화 + Working Copy로 GitHub에 발행 + 외장 키보드로 큰 화면 다 쓰기의 조합으로 9년 된 아이패드가 최강의 글쓰기 머신으로 다시 태어날 수 있게 됩니다.\n\n마치며\n\n귀찮은 일을 덜어내면 새롭게 할 수 있는 일들이 보입니다. 귀찮음에 익숙해지지 말아야겠습니다.",
    "tags": [
      "writings"
    ],
    "author": "unknown-author",
    "source": "감자도스"
  }
]