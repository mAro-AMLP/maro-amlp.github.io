[
  {
    "title": "Killing the buzzer: why I'm unreachable",
    "link": "https://mirth.cc/blog/unreachable/",
    "pubDate": "Fri, 31 Mar 2023 00:00:00 +0000",
    "excerpt": "Are you using your phone or is it using you?",
    "tags": [],
    "author": "unknown-author",
    "source": "MIRTH.CC"
  },
  {
    "title": "Unsupervised Access",
    "link": "https://mirth.cc/blog/unsupervised/",
    "pubDate": "Tue, 09 Jan 2024 17:19:00 +0000",
    "excerpt": "The harms of childhood internet use.",
    "tags": [],
    "author": "unknown-author",
    "source": "MIRTH.CC"
  },
  {
    "title": "Codeforces think-cell Round 1",
    "link": "https://tllwtg.top/2024/02/18/CF_think_cell_1/",
    "pubDate": "Sun, 18 Feb 2024 10:00:00 +0000",
    "excerpt": "题目链接点这里\n\n\n鉴定为最近码量最小的一场 CF(A~D)。\n\nCF1930A Maximise The Score\n\n排序后两两取较小值累加。这样就尽可能的使大的数不被浪费。\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nvoid solve()\n{\n    int n, ans = 0;\n    cin >> n;\n    vector<int> arr(2 * n);\n    for (auto &x: arr)\n        cin >> x;\n    sort(all(arr));\n    for (int i = 0; i < 2 * n; i += 2)\n        ans += arr[i];\n    cout << ans << endl;\n}\n\n\nCF1930B Permutation Printing\n\n找规律发现：奇偶和大小都错开排列是一种答案。（如 $8,1,6,3,4,5,2,7$）\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\nvoid solve()\n{\n    int n, cur;\n    cin >> n;\n    vector<int> arr(n + 1);\n    if (n % 2 == 0)\n    {\n        cur = n;\n        for (int i = 1; i <= n; i += 2)\n            arr[i] = cur, cur -= 2;\n        cur = 1;\n        for (int i = 2; i <= n; i += 2)\n            arr[i] = cur, cur += 2;\n    }\n    else\n    {\n        cur = n;\n        for (int i = 1; i <= n; i += 2)\n            arr[i] = cur, cur -= 2;\n        cur = 2;\n        for (int i = 2; i <= n; i += 2)\n            arr[i] = cur, cur += 2;\n    }\n    for (int i = 1; i <= n; ++i)\n        cout << arr[i] << \" \";\n    cout << endl;\n}\n\n\nCF1930C Lexicographically Largest\n\n\n  看完 C 题我的第一想法是写棵线段树，再看一眼又觉得是平衡树（）\n\n\n玩几个样例后得到结论：先将 $a[i]+i$ 从大到小排序，然后顺序输出（对应原序列的操作就是从右到左取数加入集合，这样损失是最小的）。注意输出时若当前数和上一个数相同，为避免被去重则需要减一（对应原序列的操作即先取较左边的数，再取较右边相同的数）。\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\nvoid solve()\n{\n    priority_queue<int> pq;\n    int n, x;\n    cin >> n;\n    for (int i = 1; i <= n; ++i)\n    {\n        cin >> x;\n        pq.push(x + i);\n    }\n    int last = 2e9 + 5, cur;\n    for (int i = 1; i <= n; ++i)\n    {\n        cur = pq.top();\n        pq.pop();\n        if (cur >= last)\n            cur = last - 1;\n        last = cur;\n        cout << cur << \" \";\n    }\n    cout << endl;\n}\n\n\nCF1930D1 Sum over all Substrings (Easy Version)\n\n容易发现 $[l,r]$ 取 $[i-1,i]$ 或 $[i,i+1]$ 就一定能覆盖最优的情况。然后就贪心的让 $1$ 尽量靠后出现且不浪费（只有当本位对应数字为 $1$ 且上一位和这一位没取 $1$ 的时候，下一位才取 $1$。例：$01110$ 按这样贪心得到的答案就是 $00100$）。\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\nvoid solve()\n{\n    int n, ans = 0;\n    string str;\n    cin >> n >> str;\n    function<int(string &s)> foo = [&](string &s)->int\n    {\n        s = '?' + s;\n        int sz = s.size(), res = 0;\n        vector<int> ok(sz + 1);\n        for (int i = 1; i < sz; ++i)\n            if (s[i] == '1')\n            {\n                if (ok[i - 1] == 0 && ok[i] == 0)\n                    ok[i + 1] = 1;\n            }\n        for (int i = 1; i <= sz; ++i)\n            res += ok[i];\n        return res;\n    };\n    for (int i = 0; i < n; ++i)\n        for (int j = i; j < n; ++j)\n        {\n            string s = str.substr(i, j - i + 1);\n            ans += foo(s);\n        }\n    cout << ans << endl;\n}\n\n\nCF1930D2 Sum over all Substrings (Hard Version)\n\n\n  D2 正在补。(=´ω`=)\n\n\n定义 $dp[i]$ 是以 $i$ 为左端点的所有字符串的 $f$ 值之和，并且规定从右到左进行状态转移。\n\n当前字符为 $0$ 时，不需要使用 $1$ ，即 $dp[i]=dp[i+1]$。若当前字符为 $1$，则将 $i+1$ 位置设为 $1$，这样可以兼顾 $i,i+1,i+2$ 位置上的 $1$，因此 $i$ 位置的状态就从 $i+3$ 位置的状态转移过来。由定义，这个位置作为左端点可以形成 $n-i+1$ 个字符串，所以最后的转移方程就是 $dp[i]=dp[i+3]+(n-i+1)$。\n\n然后累加 $dp$ 数组中的值作为答案。\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nvoid solve()\n{\n    ll n, ans = 0;\n    string str;\n    cin >> n >> str;\n    str = '?' + str;\n    vector<ll> dp(n + 2);\n    for(int i = n; i >= 1; --i)\n    {\n        if (str[i] == '0')\n            dp[i] = dp[i + 1];\n        else\n            dp[i] = dp[min<ll>(i + 3, n + 1)] + (n - i + 1);\n    }\n    for (int i = 1; i <= n; ++i)\n        ans += dp[i];\n    cout << ans << endl;\n}",
    "tags": [
      "code",
      "cp"
    ],
    "author": "unknown-author",
    "source": "tLLWtG Blog"
  },
  {
    "title": "Codeforces Round 923 (Div.3)",
    "link": "https://tllwtg.top/2024/02/07/CF_923/",
    "pubDate": "Wed, 07 Feb 2024 08:00:00 +0000",
    "excerpt": "题目链接点这里\n\n\n\n  G 题在补了。 (=´ω`=)\n\n\nG 题题解已更新。\n\nCF1927A Make it White\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nvoid solve()\n{\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    int a = -1, b = -1;\n    for (int i = 0; i < n; ++i)\n    {\n        if (s[i] == 'B')\n        {\n            if (a == -1)\n                a = i;\n            else\n                b = i;\n        }\n    }\n    if (a == -1)\n        cout << 0 << endl;\n    else if (b == -1)\n        cout << 1 << endl;\n    else\n        cout << b - a + 1 << endl;\n}\n\n\nCF1927B Following the String\n\n当前位置可用的字符都是等价的，所以找到次数满足条件的字符即可拿来填充答案。\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\nvoid solve()\n{\n    int n, x;\n    cin >> n;\n    map<char, int> book;\n    char cur = 'a';\n    string ans;\n    for (int i = 1; i <= n; ++i)\n    {\n        cin >> x;\n        if (x == 0)\n        {\n            ans.pb(cur);\n            book[cur++]++;\n        }\n        else\n        {\n            for (char ch = 'a'; ch < cur; ++ch)\n            {\n                if (book[ch] == x)\n                {\n                    book[ch]++;\n                    ans.pb(ch);\n                    break;\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n}\n\n\nCF1927C Choose the Different Ones!\n\n$1$ 到 $k$ 遍历过程中，若某一数字只在 $arr$ 中出现，则必从 $arr$ 中选出它，$brr$ 同理。统计各数组必选的次数，若超过 $\\frac{k}{2}$ 则无答案。\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\nvoid solve()\n{\n    int n, m, k, x, cnt1 = 0, cnt2 = 0;\n    cin >> n >> m >> k;\n    set<int> arr, brr;\n    for (int i = 0; i < n; ++i)\n        cin >> x, arr.insert(x);\n    for (int i = 0; i < m; ++i)\n        cin >> x, brr.insert(x);\n    for (int i = 1; i <= k; ++i)\n    {\n        if (arr.find(i) == arr.end() && brr.find(i) == brr.end())\n        {\n            cout << \"NO\" << endl;\n            return;\n        }\n        if (arr.find(i) != arr.end() && brr.find(i) == brr.end())\n            ++cnt1;\n        if (arr.find(i) == arr.end() && brr.find(i) != brr.end())\n            ++cnt2;\n        if (cnt1 > k / 2 || cnt2 > k / 2 )\n        {\n            cout << \"NO\" << endl;\n            return;\n        }\n    }\n    cout << \"YES\" << endl;\n}\n\n\nCF1927D Find the Different Ones!\n\n发现当前数字与下一个数字不同时，就在这个位置打上标记。然后查询时二分查找 $[l, r-1]$ 内是否存在标记。\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\nvoid solve()\n{\n    int n, q, l, r;\n    cin >> n;\n    vector<ll> arr(n + 1);\n    set<int> pos;\n    for (int i = 1; i <= n; ++i)\n        cin >> arr[i];\n    for (int i = 1; i < n; ++i)\n        if (arr[i] != arr[i + 1])\n            pos.insert(i);\n    cin >> q;\n    while (q--)\n    {\n        cin >> l >> r;\n        auto it = pos.lower_bound(l);\n        if (it == pos.end() || *it + 1 > r)\n        {\n            cout << -1 << \" \" << -1 << endl;\n            continue;\n        }\n        cout << *it << \" \" << (*it) + 1 << endl;\n    }\n    cout << endl;\n}\n\n\nCF1927E Klever Permutation\n\n将 $n=9,k=4$ 对应的方程组列出:\n\n$p_1+p_2+p_3+p_4=s_1$\n\n$p_2+p_3+p_4+p_5=s_2$\n\n$…$\n\n$p_6+p_7+p_8+p_9=s_6$\n\n然后两两相减得到：\n\n$p_5-p_1=s_2-s_1$\n\n$p_6-p_2=s_3-s_2$\n\n$…$\n\n$p_9-p_5=s_6-s_5$\n\n观察式子，发现可以将元素分为 $k$ 组，每组都有独立的递推公式（如 $p_1,p_5,p_9$ 为一组，$p_2,p_6$ 为一组）。由各个 $s$ 之间相差最多为 $1$，那么不妨令：\n\n$s_2-s_1=1$\n\n$s_3-s_2=-1$\n\n$s_4-s_3=1$\n\n$…$\n\n这样各个 $s$ 始终在两个相邻的值之间波动，此时各组元素内部是公差为 $1$ 或 $-1$ 的等差数列关系。再令 $p_1=1$，得到下面的代码。\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\nvoid solve()\n{\n    int n, k, cur = 1;\n    cin >> n >> k;\n    vector<int> ans(n + 1);\n    for (int i = 1; i <= k; ++i)\n    {\n        if (i % 2 == 1)\n        {\n            for (int j = i; j <= n; j += k)\n                ans[j] = cur++;\n        }\n        else\n        {\n            int st = n / k * k + i;\n            while (st > n)\n                st -= k;\n            for (int j = st; j >= 1; j -= k)\n                ans[j] = cur++;\n        }\n    }\n    for (int i = 1; i <= n; ++i)\n        cout << ans[i] << \" \";\n    cout << endl;\n}\n\n\nCF1927F Microcycle\n\n由“最小的边”和“环”容易想到生成树算法。用 Kruskal 构造出最大生成树，同时记录可以成环的最小的边。因为树上任意两点之间再加一条边只会形成一个环，所以用 dfs 跑一遍即可找到要求的环。\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\nclass DSU\n{\nprivate:\n    int n;\n    vector<int> fa, sz;\n \npublic:\n    DSU(int _n) : n(_n)\n    {\n        fa.resize(n + 5);\n        sz.resize(n + 5);\n        for (int i = 1; i <= n; ++i)\n        {\n            fa[i] = i;\n            sz[i] = 1;\n        }\n    }\n    int find(int x)\n    {\n        if (fa[x] == x)\n            return x;\n        else\n        {\n            fa[x] = find(fa[x]);\n            return fa[x];\n        }\n    }\n    void merge(int x, int y)\n    {\n        if (x == y)\n            return;\n        int xfa = find(x), yfa = find(y);\n        if (sz[xfa] <= sz[yfa])\n        {\n            sz[yfa] += sz[xfa];\n            fa[xfa] = yfa;\n        }\n        else\n        {\n            sz[xfa] += sz[yfa];\n            fa[yfa] = xfa;\n        }\n    }\n    int get_size(int x)\n    {\n        return sz[find(x)];\n    }\n};\n \n \nstruct edge\n{\n    int u, v, w;\n};\nstatic bool cmp(edge a, edge b)\n{\n    return a.w > b.w;\n}\n \nvoid solve()\n{\n    int n, m, u, v, w, mini = 1e9;\n    cin >> n >> m;\n    vector<vector<pii>> to(n + 1), to2(n + 1);\n    vector<edge> e(m);\n    DSU dsu(n);\n    for (int i = 1; i <= m; ++i)\n    {\n        cin >> u >> v >> w;\n        to[u].pb({v, w});\n        to[v].pb({u, w});\n        e[i - 1] = {u, v, w};\n    }\n    sort(all(e), cmp);\n    for (int i = 0; i < m; ++i)\n    {\n        if (dsu.find(e[i].u) == dsu.find(e[i].v))\n        {\n            u = e[i].u;\n            v = e[i].v;\n            mini = e[i].w;\n        }\n        else\n        {\n            to2[e[i].u].pb({e[i].v, e[i].w});\n            to2[e[i].v].pb({e[i].u, e[i].w});\n            dsu.merge(e[i].u, e[i].v);\n        }\n    }\n    vector<int> ans, vis(n + 1);\n    bool flag = false;\n    function<void(int uu, int dep)> dfs = [&](int uu, int dep)\n    {\n        ans.pb(uu);\n        vis[uu] = 1;\n        for (auto [vv, w]: to2[uu])\n        {\n            if (vis[vv])\n                continue;\n            if (vv == v)\n            {\n                if (dep <= 1)\n                    continue;\n                flag = true;\n                ans.pb(vv);\n                return;\n            }\n            else\n                dfs(vv, dep + 1);\n            if (flag)\n                return;\n        }\n        ans.pop_back();\n        vis[uu] = 0;\n    };\n    dfs(u, 1);\n    cout << mini << \" \" << ans.size() << endl;\n    for (int i = 0; i < ans.size(); ++i)\n        cout << ans[i] << \" \";\n    cout << endl;\n}\n\n\nCF1927G Paint Charges\n\n设 dp 状态：$dp[i][j][k]$ 。其意义为，当使用前 $i$ 个元素，最左侧未填充位置是 $j$ ，最右侧已填充位置是 $k$ 时，所需要的最小操作数。\n\n由定义，dp 的初始状态是 $dp[0][1][0]=0$ 。所求答案则是 $dp[n][n+1][n]$ 。\n\n然后按照 $i\\in[1,n],j\\in[1,n+1],k\\in[0,n]$ 的顺序进行状态转移。状态转移时有下面三种操作：\n\n\n  不进行操作的状态转移： $dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k])$\n  向左填充操作的状态转移：根据 $l,i,j,k$ 的大小关系讨论。\n  向右填充操作的状态转移：根据 $r,i,j,k$ 的大小关系讨论。\n\n\n转移方程见代码部分。（为方便理解，下面将八种情况都列出来了，没有简化不必要的情况）\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\nvoid solve()\n{\n    int n;\n    cin >> n;\n    vector<int> arr(n + 1);\n    for (int i = 1; i <= n; ++i)\n        cin >> arr[i];\n    vector dp(n + 3, vector(n + 3, vector<int>(n + 3, 1e3)));\n    dp[0][1][0] = 0;\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n + 1; ++j)\n            for (int k = 0; k <= n; ++k)\n            {\n                int l = max(i - arr[i] + 1, 1), r = min(i + arr[i] - 1, n);\n                dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k]);\n                // left\n                if (l <= j)\n                {\n                    if (i > k)\n                        dp[i][i + 1][i] = min(dp[i][i + 1][i], dp[i - 1][j][k] + 1);\n                    else if (i <= k)\n                        dp[i][k + 1][k] = min(dp[i][k + 1][k], dp[i - 1][j][k] + 1);\n                }\n                else if (l > j)\n                {\n                    if (i > k)\n                        dp[i][j][i] = min(dp[i][j][i], dp[i - 1][j][l] + 1);\n                    else if (i <= k)\n                        dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k] + 1);\n                }\n                // right\n                if (r > k)\n                {\n                    if (i <= j)\n                        dp[i][r + 1][r] = min(dp[i][r + 1][r], dp[i - 1][j][k] + 1);\n                    else if (i > j)\n                        dp[i][j][r] = min(dp[i][j][r], dp[i - 1][j][k] + 1);\n                }\n                else if (r <= k)\n                {\n                    if (i <= j)\n                        dp[i][k + 1][k] = min(dp[i][k + 1][k], dp[i - 1][j][k] + 1);\n                    else if (i > j)\n                        dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k] + 1);\n                }\n            }\n    cout << dp[n][n + 1][n] << endl;\n}",
    "tags": [
      "code",
      "cp"
    ],
    "author": "unknown-author",
    "source": "tLLWtG Blog"
  },
  {
    "title": "Codeforces Round 922 (Div.2)",
    "link": "https://tllwtg.top/2024/01/31/CF_922/",
    "pubDate": "Wed, 31 Jan 2024 02:00:00 +0000",
    "excerpt": "题目链接点这里\n\n\nCF1918A Brick Wall\n\n1\n2\n3\n4\n5\n6\nvoid solve()\n{\n    ll n, m;\n    cin >> n >> m;\n    cout << n * (m / 2) << endl;\n}\n\n\nCF1918B Minimize Inversions\n\n注意到，当其中一个排列有序时，总的逆序对数量最少()\n\n\n  今天找个时间补上证明\n\n\n对于任意一对 $i,j$ 位置，其可能的逆序对总贡献度 $c_{i,j}$ 为 $0,1,2$ 。由于两个排列对应位置上的元素是绑定的，所以在任意操作后只可能会出现下面几种情况：\n\n\n  总贡献度 $c_{i,j}$ 由 $0$ 变成 $2$\n  总贡献度 $c_{i,j}$ 由 $1$ 变成 $1$\n  总贡献度 $c_{i,j}$ 由 $2$ 变成 $0$\n\n\n那么令其中一个排列有序时，只会出现上面的第 2, 3 种情况（其中一个排列有序时 $c_{i,j}$ 不会取到 $2$ ）。这样所有的 $c_{i,j}$ 都取到了最小值，则此时答案最小。\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nvoid solve()\n{\n    int n;\n    cin >> n;\n    vector<pii> arr(n);\n    for (int i = 0; i < n; ++i)\n        cin >> arr[i].fi;\n    for (int i = 0; i < n; ++i)\n        cin >> arr[i].se;\n    sort(all(arr));\n    for (int i = 0; i < n; ++i)\n        cout << arr[i].fi << \" \";\n    cout << endl;\n    for (int i = 0; i < n; ++i)\n        cout << arr[i].se << \" \";\n    cout << endl;\n}\n\n\nCF1918C XOR-distance\n\n\n  为减少讨论，先假设 a > b。\n\n\n首先将 $a$,$b$ 拆位。然后根据异或的性质，当 $x$ 的某一位取 $1$ 时，会将原本的 $0$ 和 $1$ 翻转，而本题求的是差，所以只要考虑不同的位。于是贪心的从高位到低位考虑，找到第一个不同的位置 $hdig$，若 $r$ 可以取这一位为 $1$，则可以分两种情况考虑：\n\n\n  翻转该位，则会使 $a<b$，然后在后面的位置上通过翻转尽量让 $a$ 贴近 $b$。\n  不翻转该位，则保留 $a>b$，然后在后面的位置上通过翻转尽量让 $b$ 贴近 $a$。\n\n\n若 $r$ 这一位取不到 $1$，则只考虑上面的第二种情况。最后取其中的最小值作为答案。\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\nvoid solve()\n{\n    ll a, b, r;\n    cin >> a >> b >> r;\n    if (a == b || r == 0)\n    {\n        cout << abs(a - b) << endl;\n        return;\n    }\n    if (a <= b)\n        swap(a, b);\n    int hdig = -1;\n    for (int i = 62; i >= 0; --i)\n    {\n        if (((a >> i) & 1) != ((b >> i) & 1))\n        {\n            hdig = i;\n            break;\n        }\n    }\n    if (r >> hdig)\n    {\n        ll ans = 4e18;\n        // a > b\n        ll x = 0;\n        for (int i = hdig - 1; i >= 0; --i)\n            if (((a >> i) & 1) == 1 && ((b >> i) & 1) == 0)\n                if ((x ^ (1ll << i)) <= r)\n                    x ^= 1ll << i;\n        ans = min(ans, abs((a ^ x) - (b ^ x)));\n        // a < b\n        x = 1ll << hdig;\n        for (int i = hdig - 1; i >= 0; --i)\n            if (((a >> i) & 1) == 0 && ((b >> i) & 1) == 1)\n                if ((x ^ (1ll << i)) <= r)\n                    x ^= 1ll << i;\n        ans = min(ans, abs((a ^ x) - (b ^ x)));\n        cout << ans << endl;\n    }\n    else\n    {\n        // a > b\n        ll x = 0;\n        for (int i = __lg(r); i >= 0; --i)\n            if (((a >> i) & 1) == 1 && ((b >> i) & 1) == 0)\n                if ((x ^ (1ll << i)) <= r)\n                    x ^= 1ll << i;\n        cout << abs((a ^ x) - (b ^ x)) << endl;\n    }\n}\n\n\nCF1918D Blocking Elements\n\n这题用到了单调队列优化的 dp 和二分答案。\n\n首先以题目要求的最小花费为 $mid$ 进行二分。在 $check$ 函数中，我们优先确保每一段的花费不超过 $mid$，然后就要考虑如何选择分割点。\n\n在 $check$ 时直接贪心的选择分割点会 WA，所以我们用 dp 优化选择。定义 $dp[i]$ 是仅考虑前 $i$ 个位置，并且以第 $i$ 个位置作为分割点的分割点花费之和。在求 $dp$ 值时，先用双指针+前缀和快速确定一个 $j$ 位置，使得 $j$ 到 $i-1$ 这段的花费不大于 $mid$，即这些位置都是可以向 $dp[i]$ 转移的位置。然后根据单调队列的性质，队首即是可转移的最小值。最后检查分割点的花费之和是否超过了 $mid$，即 $dp[n + 1]$ 是否大于 $mid$。\n\n\n  dp 转移方程：$dp[i]=\\min \\limits_{j \\le x \\le i-1}(dp[x]) + arr[i]$\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\nvoid solve()\n{\n    int n;\n    cin >> n;\n    vector<ll> arr(n + 2), pre(n + 2);\n    for (int i = 1; i <= n; ++i)\n        cin >> arr[i], pre[i] = pre[i - 1] + arr[i];\n    ll l = 1, r = 1e14, mid, ans = 1;\n    function<bool(ll x)> check = [&](ll x)->bool\n    {\n        vector<ll> dp(n + 2);\n        deque<ll> dq;\n        dq.pb(0);\n        for (int i = 1, j = 0; i <= n + 1; ++i)\n        {\n            while (pre[i - 1] - pre[j] > x)\n                ++j;\n            while (!dq.empty() && dq.front() < j)\n                dq.pop_front();\n            if (dq.empty())\n                return false;\n            dp[i] = dp[dq.front()] + arr[i];\n            while(!dq.empty() && dp[dq.back()] >= dp[i])\n                dq.pop_back();\n            dq.pb(i);\n        }\n        return dp[n + 1] <= x;\n    };\n    while (l <= r)\n    {\n        mid = (l + r) / 2;\n        if (check(mid))\n        {\n            ans = mid;\n            r = mid - 1;\n        }\n        else\n            l = mid + 1;\n    }\n    cout << ans << endl;\n}",
    "tags": [
      "code",
      "cp"
    ],
    "author": "unknown-author",
    "source": "tLLWtG Blog"
  },
  {
    "title": "Codeforces Round 921 (Div.2)",
    "link": "https://tllwtg.top/2024/01/28/CF_921/",
    "pubDate": "Sun, 28 Jan 2024 21:30:00 +0000",
    "excerpt": "题目链接点这里\n\n\n赛时 D 题题意读假了 :(\n\nCF1925A We Got Everything Covered!\n\n前 $k$ 个字母按顺序排序 $n$ 次是一种解。\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nvoid solve()\n{\n    int n, k;\n    cin >> n >> k;\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= k; ++j)\n            cout << char('a' + j - 1);\n    cout << endl;\n}\n\n\nCF1925B A Balanced Problemset?\n\n写出题意中的表达式：$d \\times (a_1+a_2+…+a_{n})=x$。则容易想到枚举 $x$ 的因数 $d$，当 $\\frac{x}{d}$ 大于等于 $n$ 时可以作为一个可行解，所有解中的最大值即为答案。\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nvoid solve()\n{\n    int x, n, ans = 1;\n    cin >> x >> n;\n    int lim = sqrt(x);\n    for (int i = 1; i <= lim; ++i)\n    {\n        if (x % i)\n            continue;\n        int d1 = i;\n        int d2 = x / i;\n        if (d2 >= n)\n            ans = max(ans, d1);\n        if (d1 >= n)\n            ans = max(ans, d2);\n    }\n    cout << ans << endl;\n}\n\n\nCF1925C Did We Get Everything Covered?\n\n首先判断必要条件：前 $k$ 个字母出现次数均大于等于 $n$。然后试几个样例可以发现，可行的字符串都能分割成若干子序列，每一个子序列里前 $k$ 个字母都至少出现过一次。若字符串 $s$ 可以分割成大于等于 $n$ 个这样子序列（从前往后遍历，每次形成符合条件的子序列时就开始统计下一个子序列），答案为 YES。\n\n答案为 NO 时需要输出一个反例。可以贪心的取每个子序列的末端字符拼接在一起，剩下的空位用最后一段残缺子序列中没有的字符补全。\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\nvoid solve()\n{\n    int n, k, m;\n    string s;\n    cin >> n >> k >> m;\n    cin >> s;\n    map<char, int> cnt;\n    for (char ch: s)\n        cnt[ch]++;\n    for (char ch = 'a'; ch < 'a' + k; ++ch)\n    {\n        if (cnt[ch] < n)\n        {\n            cout << \"NO\" << endl;\n            for (int i = 1; i <= n; ++i)\n                cout << ch;\n            cout << endl;\n            return;\n        }\n    }\n    int sumi = 0;\n    vector<int> book(30, 0);\n    string ans;\n    for (char ch: s)\n    {\n        book[ch - 'a']++;\n        bool flag = true;\n        for (char c = 'a'; c < 'a' + k; ++c)\n        {\n            if (!book[c - 'a'])\n                flag = false;\n        }\n        if (flag)\n        {\n            ans.pb(ch);\n            fill(all(book), 0);\n            ++sumi;\n        }\n    }\n    if (sumi < n)\n    {\n        cout << \"NO\" << endl;\n        int ind = 0;\n        for (int i = 0; i < k; ++i)\n        {\n            if (book[i] == 0)\n                ind = i;\n        }\n        for (int i = 1; i <= n - sumi; ++i)\n            ans.pb('a' + ind);\n        cout << ans << endl;\n        return;\n    }\n    cout << \"YES\" << endl;\n}\n\n\nCF1925D Good Trip\n\n\n  代码用到的模板在文末。\n\n\n先理解一下加分规则（赛时这个地方没仔细看 TT）：某条边权值为 $f$，则第一次被选中后答案加上 $f$，第二次被选中后答案再加上 $f+1$ …\n\n每轮有 $C_{n}^{2}$ 种选择，记为 $p$，则 $k$ 轮共有 $p^k$ 种可能结果。另外记 $s$ 为所有边的权值之和。\n\n然后计算单条边的贡献：\n\n  只选择一次这条边时，贡献度为 $f \\times C_{k}^{1} \\times (p-1)^{k-1}$\n  只选择两次这条边时，贡献度为 $(f+f+1) \\times C_{k}^{2} \\times (p-1)^{k-2}$\n  …\n\n\n归纳得到选择了 $i$ 次这条边时的贡献度为 $(f+f+1+…+f+i-1) \\times C_{k}^{i} \\times (p-1)^{k-i}$\n\n然后求和得到这条边总的贡献度 $\\sum_{i = 1}^{k}(f+f+1+…+f+i-1) \\times C_{k}^{i} \\times (p-1)^{k-i}$\n\n再将每条边的贡献度相加得到总贡献度 $S=\\sum_{i = 1}^{k}(s+s+m+…+s+m \\times (i-1)) \\times C_{k}^{i} \\times (p-1)^{k-i}$\n\n最后计算数学期望，用总贡献度除以所有可能的结果数 $E= \\frac{S}{p^k}$\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nvoid solve()\n{\n    int n, m, k, f, x, y;\n    cin >> n >> m >> k;\n    mint sumi = 0, ans = 0, d, p = comb::C(n, 2);\n    for (int i = 1; i <= m; ++i)\n    {\n        cin >> x >> y >> f;\n        sumi += f;\n    }\n    d = p.pow(k);\n    mint tsumi = 0;\n    for (int i = 1; i <= k; ++i)\n    {\n        tsumi += sumi + ll(m) * (i - 1);\n        ans += tsumi * comb::C(k, i) * (p - 1).pow(k - i);\n    }\n    cout << ans / d << endl;\n}\n\n\n模板\n\n1. 自动取模的整数类\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\ntemplate<const int T>\nclass ModInt {\n    const static int mod = T;\n    int x;\n \n    public:\n        ModInt(int x = 0) : x(x % mod) {}\n        ModInt(long long x) : x(int(x % mod)) {} \n        int val() { return x; }\n        ModInt operator + (const ModInt &a) const { int x0 = x + a.x; return ModInt(x0 < mod ? x0 : x0 - mod); }\n        ModInt operator - (const ModInt &a) const { int x0 = x - a.x; return ModInt(x0 < 0 ? x0 + mod : x0); }\n        ModInt operator * (const ModInt &a) const { return ModInt(1LL * x * a.x % mod); }\n        ModInt operator / (const ModInt &a) const { return *this * a.inv(); }\n        bool operator == (const ModInt &a) const { return x == a.x; };\n        bool operator != (const ModInt &a) const { return x != a.x; };\n        void operator += (const ModInt &a) { x += a.x; if (x >= mod) x -= mod; }\n        void operator -= (const ModInt &a) { x -= a.x; if (x < 0) x += mod; }\n        void operator *= (const ModInt &a) { x = 1LL * x * a.x % mod; }\n        void operator /= (const ModInt &a) { *this = *this / a; }\n        friend ModInt operator + (int y, const ModInt &a){ int x0 = y + a.x; return ModInt(x0 < mod ? x0 : x0 - mod); }\n        friend ModInt operator - (int y, const ModInt &a){ int x0 = y - a.x; return ModInt(x0 < 0 ? x0 + mod : x0); }\n        friend ModInt operator * (int y, const ModInt &a){ return ModInt(1LL * y * a.x % mod);}\n        friend ModInt operator / (int y, const ModInt &a){ return ModInt(y) / a;}\n        friend ostream &operator<<(ostream &os, const ModInt &a) { return os << a.x;}\n        friend istream &operator>>(istream& is, ModInt& t){return is >> t.x;}\n \n        ModInt pow(int64_t n) const {\n            ModInt res(1), mul(x);\n            while(n){\n                if (n & 1) res *= mul;\n                mul *= mul;\n                n >>= 1;\n            }\n            return res;\n        }\n        ModInt inv() const {\n            int a = x, b = mod, u = 1, v = 0;\n            while (b) {\n                int t = a / b;\n                a -= t * b; swap(a, b);\n                u -= t * v; swap(u, v);\n            }\n            if (u < 0) u += mod;\n            return u;\n        }\n};\n \nconst int MOD = 1e9 + 7;\n \nusing mint = ModInt<MOD>;\n\n\n2. 带模数的组合数模板\n\n\n  使用前需要用 Preprocess 函数进行预处理。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\nnamespace comb\n{\n    int n, p;\n    vector<int> inv, fac, finv;\n    void Preprocess(int _n, int _p)\n    {\n        n = _n;\n        p = _p;\n        inv.resize(n + 5);\n        fac.resize(n + 5);\n        finv.resize(n + 5);\n        inv[1] = 1;\n        for (int i = 2; i <= n + 1; ++i)\n            inv[i] = (ll)(p - p / i) * inv[p % i] % p;\n        fac[0] = 1;\n        for (int i = 1; i <= n + 1; ++i)\n            fac[i] = (ll)fac[i - 1] * i % p;\n        finv[0] = 1;\n        for (int i = 1; i <= n + 1; ++i)\n            finv[i] = (ll)finv[i - 1] * inv[i] % p;\n    }\n    int C(int x, int y) { return (ll)fac[x] * finv[y] % p * finv[x - y] % p; }\n}",
    "tags": [
      "code",
      "cp"
    ],
    "author": "unknown-author",
    "source": "tLLWtG Blog"
  },
  {
    "title": "Educational Codeforces Round 161",
    "link": "https://tllwtg.top/2024/01/20/CF_Edu161/",
    "pubDate": "Sat, 20 Jan 2024 13:00:00 +0000",
    "excerpt": "题目链接点这里\n\n\n111 上大分了。\n\n\n\nCF1922A Tricky Template\n\n只要存在一个位置，使得 $c$ 和 $a, b$ 均不同就能构造出答案。\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\nvoid solve()\n{\n    int n;\n    cin >> n;\n    string a, b, c;\n    cin >> a >> b >> c;\n    for (int i = 0; i < n; ++i)\n    {\n        if (a[i] != c[i] && b[i] != c[i])\n        {\n            cout << \"YES\" << endl;\n            return;\n        }\n    }\n    cout << \"NO\" << endl;\n}\n\n\nCF1922B Forming Triangles\n\n注意到只有两个相同长度的木棍和另一个小于等于这个长度的木棍能够组成三角形。然后就可以用组合数公式计算答案。\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nvoid solve()\n{\n    ll n, x, ans = 0, cnt = 0;\n    cin >> n;\n    map<int, int> book;\n    for (int i = 1; i <= n; ++i)\n    {\n        cin >> x;\n        book[x]++;\n    }\n    for (auto [x, y]: book)\n    {\n        ll num = y;\n        if (num >= 2)\n            ans += cnt * num * (num - 1) / 2;\n        if (num >= 3)\n            ans += num * (num - 1) * (num - 2) / 6;\n        cnt += num;\n    }\n    cout << ans << endl;\n}\n\n\nCF1922C Closest Cities\n\n\n  时隔一年我又犯了等号写成赋值的错误，令人感慨。（老玩家集体类目）\n\n\n首先观察出能用最近点传送就一定用上，并且不会出现往回走的情况。然后看数据范围，要求快速计算两点间最短距离，那显然用前缀和做最合适了。先预处理出每个点的最近点，存在 $cls$ 里，然后从两个方向分别前缀和。\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\nvoid solve()\n{\n    int n, m;\n    cin >> n;\n    vector<ll> arr(n + 1);\n    for (int i = 1; i <= n; ++i)\n        cin >> arr[i];\n    vector<ll> pre_lr(n + 1, 0), pre_rl(n + 1, 0);\n    vector<ll> cls(n + 1, 0);\n    cls[1] = 2;\n    cls[n] = n - 1;\n    for (int i = 2; i <= n - 1; ++i)\n    {\n        if (arr[i] - arr[i - 1] < arr[i + 1] - arr[i])\n            cls[i] = i - 1;\n        else\n            cls[i] = i + 1;\n    }\n    for (int i = 2; i <= n; ++i)\n    {\n        if (cls[i - 1] == i)\n            pre_lr[i] = pre_lr[i - 1] + 1;\n        else\n            pre_lr[i] = pre_lr[i - 1] + arr[i] - arr[i - 1];\n    }\n    for (int i = n - 1; i >= 1; --i)\n    {\n        if (cls[i + 1] == i)\n            pre_rl[i] = pre_rl[i + 1] + 1;\n        else\n            pre_rl[i] = pre_rl[i + 1] + abs(arr[i] - arr[i + 1]);\n    }\n    cin >> m;\n    while (m--)\n    {\n        int l, r;\n        cin >> l >> r;\n        if (l < r)\n        {\n            cout << pre_lr[r] - pre_lr[l] << endl;\n        }\n        else if (l > r)\n        {\n            cout << pre_rl[r] - pre_rl[l] << endl;\n        }\n    }\n}\n\n\nCF1922D Berserk Monsters\n\n这道题需要一个能灵活删除元素的线性结构，那么就很容易想到用双向链表来存储怪兽。同时注意到，只有上一轮死亡怪物的左右两个位置才有可能在下一轮再发生变动。于是可以用 $acti$ 来存储可能发生变动的位置。一开始所有位置都存入 $acti$ 内，在每一轮去查询 $acti$ 内存的位置对应的怪物是否死亡，若死亡则把左右两个怪物加入下一轮的 $acti$ 中，像这样不断的模拟 $n$ 轮即得到答案。\n\n再分析一下时间复杂度，存入 $acti$ 内的怪物数量是是一个常数乘上 $n$，$set$ 本身操作是 $\\log{n}$ 级别，于是总的时间复杂度是 $O(n \\log{n})$。\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\nvoid solve()\n{\n    int n;\n    cin >> n;\n    vector<int> arr(n + 1), drr(n + 1);\n    for (int i = 1; i <= n; ++i)\n        cin >> arr[i];\n    for (int i = 1; i <= n; ++i)\n        cin >> drr[i];\n    vector<pii> adj(n + 1);\n    for (int i = 1; i <= n; ++i)\n        adj[i].fi = i - 1, adj[i].se = i + 1;\n    adj[1].fi = -1;\n    adj[n].se = -1;\n    set<int> acti;\n    for (int i = 1; i <= n; ++i)\n        acti.insert(i);\n    int round = n;\n    while (round--)\n    {\n        int dead = 0;\n        map<int, int> dmg;\n        for (auto id: acti)\n        {\n            int l = adj[id].fi;\n            int r = adj[id].se; \n            if (l != -1)\n            {\n                dmg[l] += arr[id];\n                if (acti.find(l) == acti.end())\n                    dmg[id] += arr[l];\n            }\n            if (r != -1)\n            {\n                dmg[r] += arr[id];\n                if (acti.find(r) == acti.end())\n                    dmg[id] += arr[r];\n            }\n        }\n        acti.clear();\n        for (auto [id, sumi]: dmg)\n        {\n            if (sumi > drr[id])\n            {\n                dead++;\n                int l = adj[id].fi;\n                int r = adj[id].se; \n                if (l != -1 && r != -1)\n                {\n                    acti.insert(l);\n                    acti.insert(r);\n                    adj[l].se = r;\n                    adj[r].fi = l;\n                }\n                else if (l == -1 && r != -1)\n                {\n                    acti.insert(r);\n                    adj[r].fi = -1;\n                }\n                else if (r == -1 && l != -1)\n                {\n                    acti.insert(l);\n                    adj[l].se = -1;\n                }\n            }\n        }\n        for (auto [id, sumi]: dmg)\n        {\n            if (sumi > drr[id])\n                acti.erase(id);\n        }\n        cout << dead << \" \";\n    }\n    cout << endl;\n}\n\n\nCF1922E Increasing Subsequences\n\n这题有两种思路，一种是套递增子序列模型，一种是找规律。\n\n解1\n\n求递增子序列（IS）数量是一个经典的动态规划问题，这题反过来，给定数量要求构造原序列。\n\n首先抽象出下面两个操作（设 $x$ 是 IS 的数量，不考虑空子序列）：\n\n\n  在数组末尾添加一个最小的数，则 $x$ 变为 $x+1$。\n  在数组末尾添加一个比所有数都大的数，则 $x$ 变为 $2 \\times x+1$。\n\n\n然后逆向的考虑如何将 $x$ 变为 $0$：\n\n\n  $x$ 为偶数时，在数组前面添加一个最小的数，则 $x$ 变为 $x-1$。\n  $x$ 为奇数时，在数组前面添加 $cur$，则 $x$ 变为 $\\frac{x-1}{2}$。\n\n\n逆向操作形成的数组即为答案。\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\nvoid solve()\n{\n    ll x;\n    vector<int> ans;\n    cin >> x;\n    --x;\n    int cur = 100;\n    while (x != 0)\n    {\n        if (x % 2 == 0)\n        {\n            ans.pb(0);\n            --x;\n        }\n        else\n        {\n            ans.pb(cur--);\n            x /= 2;\n        }\n    }\n    reverse(all(ans));\n    cout << ans.size() << endl;\n    for (auto x : ans)\n        cout << x << \" \";\n    cout << endl;\n}\n\n\n解2\n\n由二项式定理得 $0, 1, 2, 3, …, x-1$ 的 IS 数量为 $2^x$。然后发现规律：先找出最大的 $x$，然后从大到小遍历每一个二进制位。如果第 $i$ 位是 $1$，则在序列最后添加一个 $i$，这样操作会让答案增加 $2^i$。\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nvoid solve()\n{\n    ll x;\n    cin >> x;\n    int maxi = __lg(x);\n    vector<int> ans;\n    for (int i = 0; i < maxi; ++i)\n        ans.pb(i);\n    for (int i = maxi - 1; i >= 0; --i)\n    {\n        if ((x >> i) & 1)\n            ans.pb(i);\n    }\n    cout << ans.size() << endl;\n    for (auto x: ans)\n        cout << x << \" \";\n    cout << endl;\n}",
    "tags": [
      "code",
      "cp"
    ],
    "author": "unknown-author",
    "source": "tLLWtG Blog"
  },
  {
    "title": "Codeforces Round 920 (Div.3)",
    "link": "https://tllwtg.top/2024/01/19/CF_920/",
    "pubDate": "Fri, 19 Jan 2024 17:30:00 +0000",
    "excerpt": "题目链接点这里\n\n\n这场 div3 F 题的算法很基础，但是我此前居然完全没接触过。（芙莉莲震惊.jpg）\n\n不过这下能够算法沙漠面积--了。\n\nCF1921A Square\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\nvoid solve()\n{\n    int x1 = 1e9, y1 = 1e9, x2 = -1e9, y2 = -1e9, x, y;\n    for (int i = 1; i <= 4; ++i)\n    {\n        cin >> x >> y;\n        x1 = min(x, x1);\n        y1 = min(y, y1);\n        x2 = max(x, x2);\n        y2 = max(y, y2);\n    }\n    cout << (x2 - x1) * (y2 - y1) << endl;\n}\n\n\nCF1921B Arranging Cats\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\nvoid solve()\n{\n    int n;\n    cin >> n;\n    string s1, s2;\n    cin >> s1 >> s2;\n    int diff = 0, ans = 0;\n    for (int i = 0; i < n; ++i)\n    {\n        if (s1[i] == '0' && s2[i] == '1')\n        {\n            if (diff < 0)\n            {\n                ++ans;\n                ++diff;\n            }\n            else\n            {\n                ++diff;\n            }\n        }\n        else if (s1[i] == '1' && s2[i] == '0')\n        {\n            if (diff > 0)\n            {\n                ++ans;\n                --diff;\n            }\n            else\n            {\n                --diff;\n            }\n        }\n    }\n    cout << ans + abs(diff) << endl;\n}\n\n\nCF1921C Sending Messages\n\n每次发信息前都贪心的进行抉择，选最优的方案。若最优的方案都无法满足则 NO，否则 YES。注意数数数清楚。\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\nvoid solve()\n{\n    ll n, f, a, b, m;\n    cin >> n >> f >> a >> b;\n    ll last = 0, sumi = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        cin >> m;\n        if (i == 1)\n        {\n            if ((m - last) * a >= b)\n                sumi += b;\n            else\n                sumi += (m - last) * a;\n            last = m;\n            continue;\n        }\n        if ((m - last) * a >= b)\n            sumi += b;\n        else\n            sumi += (m - last) * a;\n        last = m;\n    }\n    if (sumi < f)\n        cout << \"YES\" << endl;\n    else\n        cout << \"NO\" << endl;\n}\n\n\nCF1921D  Very Different Array\n\n容易想到将数组排序并翻转，从而尽量将大数和小数匹配。接着贪心的从 $brr$ 的两端选出绝对值之差更大的数，直到已选了出 $n$ 个数。\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\nvoid solve()\n{\n    ll n, m, ans = 0;\n    cin >> n >> m;\n    vector<ll> arr(n), brr(m);\n    for (int i = 0; i < n; ++i)\n        cin >> arr[i];\n    for (int i = 0; i < m; ++i)\n        cin >> brr[i];\n    sort(all(arr));\n    sort(all(brr));\n    reverse(all(brr));\n    int l = 0, r = m - 1, cl = 0, cr = n - 1, cnt = 0;\n    while (cl <= cr && cnt <= n)\n    {\n        if (abs(brr[l] - arr[cl]) >= abs(brr[r] - arr[cr]))\n        {\n            ans += abs(brr[l] - arr[cl]);\n            ++l, ++cl;\n        }\n        else\n        {\n            ans += abs(brr[r] - arr[cr]);\n            --r, --cr;\n        }\n    }\n    cout << ans << endl;\n}\n\n\nCF1921E Eat the Chip\n\n$x_1 \\ge x_2$ 的时候不会发生相遇，是平局。然后考虑 $x_1 \\le x_2$。当 $step$ 为偶数时，只会发生 Alice 赢或平局的情况。因为数据范围不大，这时可以暴力模拟每一步，并令 Bob 逃离 Alice，Alice 追赶 Bob。最后看是否追上即可判断结果。$step$ 为奇数的讨论同上。\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\nvoid solve()\n{\n    ll h, w, x1, y1, x2, y2;\n    cin >> h >> w >> x1 >> y1 >> x2 >> y2;\n    ll step = abs(x2 - x1 - 1);\n    if (x1 >= x2)\n    {\n        cout << \"Draw\" << endl;\n    }\n    else if (step % 2 == 0)\n    {\n        for (int i = 1; i <= step; ++i)\n        {\n            if (i % 2 == 1)\n            {\n                if (y2 > y1)\n                    ++y1;\n                else if (y2 < y1)\n                    --y1;\n            }\n            else if (i % 2 == 0)\n            {\n                if (y2 > y1 && y2 < w)\n                    ++y2;\n                else if (y2 < y1 && y2 > 1)\n                    --y2;\n            }\n        }\n        if (abs(y2 - y1) <= 1)\n            cout << \"Alice\" << endl;\n        else\n            cout << \"Draw\" << endl;\n    }\n    else\n    {\n        for (int i = 1; i <= step; ++i)\n        {\n            if (i % 2 == 1)\n            {\n                if (y2 > y1 && y1 > 1)\n                    --y1;\n                else if (y2 < y1 && y1 < w)\n                    ++y1;\n            }\n            else if (i % 2 == 0)\n            {\n                if (y2 > y1)\n                    --y2;\n                else if (y2 < y1)\n                    ++y2;\n            }\n        }\n        if (abs(y2 - y1) <= 1)\n            cout << \"Bob\" << endl;\n        else\n            cout << \"Draw\" << endl;\n    }\n}\n\n\nCF1921F Sum of Progression\n\n这题用到下面两个算法。\n\n  \n    带权前缀和\n\n    $sum_{l-1}=a_1+2 \\times a_2+3 \\times a_3+…+(l-1) \\times a_{l-1}$\n\n    $sum_{r}=a_1+2 \\times a_2+3\\times a_3+…+l \\times a_l+…+r \\times a_r$\n\n    $sum_{r}-sum_{l-1}=l \\times a_l+…+r \\times a_r=(l-1) \\times (a_l+…+a_r)+a_l+…+a_r$\n  \n  \n    根号分治\n\n    找到两种算法，复杂度分别为 $O(D)$ 与 $O(\\frac{n}{D})$ (或者类似的复杂度)。每次根据数据大小选取具体使用的算法。取分界点 $D=\\sqrt{n}$，可将复杂度降至 $O(q \\times \\sqrt{n})$。\n  \n\n\n这题的带权前缀和按公差分为 $lim$ 组，分别进行预处理。分界点可取 $200$，大于两百的数据暴力求解，小于两百的数据用带权前缀和直接计算答案。\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\nint n, q, lim = 200;\nvector<vector<ll>> pre(lim, vector<ll>(1e5 + lim * 2 + 1));\nvector<vector<ll>> sumi(lim, vector<ll>(1e5 + lim * 2 + 1));\n \nvoid solve()\n{\n    cin >> n >> q;\n    vector<ll> arr(n + 1);\n    \n    for (int i = 0; i < n; ++i)\n        cin >> arr[i];\n    for (int d = 1; d < lim; ++d)\n        for (int i = 0; i < n; ++i)\n        {\n            pre[d][i + d] = pre[d][i] + arr[i];\n            sumi[d][i + d] = sumi[d][i] + arr[i] * (i / d + 1);\n        }\n    while (q--)\n    {\n        ll s, d, k;\n        cin >> s >> d >> k;\n        --s;\n        if (d < lim)\n        {\n            int r = s + d * k, l = s;\n            cout << sumi[d][r] - sumi[d][l] - (l / d) * (pre[d][r] - pre[d][l]) << \" \";\n        }\n        else\n        {\n            ll ans = 0;\n            for (int i = 0; i < k; ++i)\n                ans += arr[i * d + s] * (i + 1);\n            cout << ans << \" \";\n        }\n    }\n}",
    "tags": [
      "code",
      "cp"
    ],
    "author": "unknown-author",
    "source": "tLLWtG Blog"
  },
  {
    "title": "First Year in XMU",
    "link": "https://tllwtg.top/2023/09/05/First-Year/",
    "pubDate": "Tue, 05 Sep 2023 23:00:00 +0000",
    "excerpt": "上半学期的内容不再赘述了，讲讲下半学期和小学期发生的新鲜事。\n\n  PS: 虾大的小学期将在明年被丢进历史的垃圾堆里（好！\n\n\n\n\nLIFE\n\n志愿服务\n\n开始做志愿服务的动机是学校评奖评优需要一定的志愿时长。上学期因为新冠，学校里几乎没有志愿活动可做，于是这学期初我就在焦虑的驱使下开始到处找志愿工作。三到六月里我先后做了社区四点半课堂的老师，垃圾分类志愿者，自行车摆放志愿者，创客大赛工作人员，自习室管理员，无忧 e 课堂答疑和管理员。然后做着做着就远远超过了所需的志愿时长 XD，大概是领悟到了志愿服务的魅力，这与我在小学中学做的装装样子的志愿服务很不一样。\n\n\n  志愿汇上记录着的 30+ 小时志愿服务时长。\n\n\n\n\n\n  在隔壁沙美社区的一座宗祠里，我和其他志愿者在教小朋友下象棋。\n\n\n\n\n\n  下雨天也要坚持垃圾分类（国光五附近有概率刷出一群爱聊天的留学生噢）\n\n\n\n\n\n  创客大赛，一半的时间都在和学姐聊天摸鱼()\n\n\n\n\n击剑比赛\n\n击剑期末考打到 rk1 后，李生老师让我去报名了校击剑比赛。说是“新生杯”，实际上有好多经验丰富的击剑社社员参与，于是我就在八强的淘汰赛遗憾离场。\n\n\n\nKFC\n\n校内的 KFC 在学期初开张了，生意好的时候一天有 2k 单左右。(食堂震怒 XD)\n\n\n  湖边吃汉堡还挺香。\n\n\n\n\n\n  热辣香骨鸡！\n\n\n\n\n新冠\n\nCSP 认证打到一半的时候，我发现我的脑子转不动了，心跳也很快。我那时就在想，“大模拟题劲这么大的吗”。之后 debug 两个小时也没查出来少加的那个括号，最终以不到 300 分的成绩遗憾离场。出考场吹了会风还没缓过来，我意识到我可能发烧了。于是随便吃了点面包，然后回宿舍测抗原。接着就是下图。那段时间大概有五分之一的人中奖初阳或二阳。\n\n\n  初阳\n\n\n\n\n\n  第二次入住南存钿，(二人间+空调+送餐+不用上课) * 五天\n\n\n\n\nGPA\n\n理工科的课程都是 90+！思政类课程就缺点悟性了。另外大英四真是选课决定成绩，奇怪的老师和奇怪的考核都让我撞上了:( 这学期的课程变难+绩点变高理论上会让我的排名上升一点的，但是顶不住有几十个转专业来的佬+卷王梭哈计科，于是就 9% 变 22% 了。。。没逝，按规律转专业的同学之后排名掉的很快。\n\n\n  成绩单（小学期成绩还没出）\n\n\n\n\n\n  计科排名\n\n\n\n\n\n  大类排名\n\n\n\n\n\n  上学期的大类排名（对比发现信院人数增加了135人。。。）\n\n\n\n\n专业\n\n兜兜转转又决定是计科了。学软工似乎会把路走窄了，既然还没想好以后要做什么，不如先留条后路。唯一的问题是，评奖评优和保研始终会被一众佬压着。\n\n\n\n小学期项目\n\n选课之前听说这位老师很水，遂被骗去。第一节课上便要求我们看着英文文档去学习 SFML，一个 C++ 的多媒体库。并在之后的三周时间里组队做出一款游戏，还要在每周汇报进度。在两个十分靠谱的队友的帮助下，我们在 DDL 前完成了质量不错的游戏，游戏制作中小组的讨论与协作也很愉快。非常感谢他们。\n\n\n  这是项目主页\n\n\n\n\n\n  高质量开始菜单\n\n\n\n\n\n  游戏内截图\n\n\n\n\n留校\n\n因为暑假有 ACM 队的集训，我在小学期结束后又继续留校到 8 月 20 号。一个人待在宿舍非常舒适。\n\n\n  下午去操场包场。\n\n\n\n\n\n  猜猜这是凌晨还是傍晚？\n\n\n\n\n黑天鹅\n\n难得见到湖里的黑天鹅上岸。\n\n\n  吉兆：学长上岸！\n\n\n\n\n\n  学长们大概是喝腻了湖里的水。\n\n\n\n\n料理\n\n假期里尝试补上过去十几年都没关注过的料理技能树，跟着 up 主大碗拿铁的“有手就能做”系列做了一些唬人的菜：“麻辣水煮鱼”、“糖醋排骨”、“西冷牛排”、“蜜制烤鸡翅”。图见大碗拿铁视频（歌门不会拍料理，库鲁西）\n\n番\n\n发现一个可以做番剧统计与交流的老站，bangumi，功能和资料都好全，甚至还开放 api，我哭似。bgm 到现在为止已经运营了超过十年，所以你能在老番的条目下，看到数年前的人们在追番时留下的评论，真有种穿越时空的感觉。我现在在想着用它的 api 能做些什么有趣的项目。\n\n\n\n\n\nCP\n\n蓝桥杯国赛\n\n\n  不出意外的拿下国三，明年要更进一步。\n\n\n\n\n校赛\n\n\n  校赛都差点打铁 xsl\n\n\n\n\nCSP\n\n200+ 分，这下真打铁了。原因见新冠篇。待我 12 月份二战 CSP！\n\n百度之星\n\n第一场平台出锅了，参赛人数比较少，于是我悄悄摸了个金奖。现在在考虑要不要去线下决赛，毕竟百度之星还没正式进学院的竞赛库，同时学校也不提供来回费用的报销。（另外，去一趟杭州好麻烦啊。。。）\n\n\n\n网络赛\n\n网络赛打出了 WF 的难度，真坐牢 5h。除了计算几何差一点点就做出来了有点可惜外，其他是一点不会。\n\n\n  队伍改名为“我推的Acmer！”，并临时换了一位队友。\n\n\n\n\n牛客\n\n暑假集训的主要项目，牛客多校。要问为什么没报隔壁的杭电多校，怕坐牢（即答\n\n\n  有游戏体验，但不多。\n\n\n\n\nUCup\n\n鉴定为良心比赛，下个学期的加训拜托了。stO Universal Cup。\n\n\n\nCF\n\n\n  在蓝名边缘卡了几个月后终于开始向上震荡。我越发觉得写题的心态很重要，要是初见就认为自己写不出来，或者给自己定了无形的上限，那就真的不会再有突破。\n\n\n\n\n\n  第一次帮 CF round 验题，上首页了很开心。\n\n\n\n\n模板\n\n\n  暑假补上了好多科技，并整理到了我的模板库里。\n\n\n\n\n\n  Full List（大多数模板都是封装好的>v<）\n\n\n\n\n\n\n结尾\n\n哦嗨哟！新学期！",
    "tags": [
      "code",
      "cp",
      "life",
      "xmu"
    ],
    "author": "unknown-author",
    "source": "tLLWtG Blog"
  },
  {
    "title": "Competitive Programming",
    "link": "https://tllwtg.top/2023/05/01/CP/",
    "pubDate": "Mon, 01 May 2023 00:00:00 +0000",
    "excerpt": "一段奇妙的算法竞赛之旅就此展开……\n\n\nXCPC\n\n芜湖，经过层层选拔，还有最后的面试——历时半年，tLLWtG 终于进入了 XMU 的 XCPC 团队，可喜可贺可喜可贺。虽然没能在校内选拔赛中打到邀请赛的名额有点遗憾，但是总算迈出了我在 XCPC 上的第一步：）\n\n\n  零基础蒟蒻类目了\n\n\n\n\n这是我目前所在的 ACM 小队（别问我为什么变成青名了）。队伍名“为美好的世界献上代码”的由来非常明显，没错，就是那部十分清奇的异世界番，《为美好的世界献上祝福》（素晴）。正好最近又在播素晴的前传，《为美好的的世界献上爆炎》（听说第三季也会在今年播出，好耶），于是就顺理成章的蹭个热度，用了这样的队名 XD\n\n\n\n天梯赛\n\n各种因缘巧合的促使下，我进入了 XMU 的天梯赛二队，在上上周代表虾大参加了比赛。原本以为自己的分数会在队内垫底，没想到最后打的还可以，压线摸了一个个人三等奖，好好好。\n\n赛中出乎意料的被 l1-6 的字符串操作卡住，接着又被 l2-1，l2-2 的模拟封死，一度以为我就要止步于此了，但是经过一番殊死搏斗，还是打完了 l2，其中只跳了 l2-3 的构造。这个时候只剩下十几分钟的时间，已经来不及写构造题了，但是离国三又只差几分而已。hihihi，那就上点不讲武德的东西。通过直接输出”No Solution”和”0”，我又骗到了关键的 3 分，刚好凑到国三线的 175 分。（赛后听人说，l3 的某道题输出 20 可以白拿 15 分 ？。？）\n\n\n\n蓝桥杯\n\n最近蓝桥杯的成绩也出来了，虽然早有耳闻蓝桥杯的含金量（），但是在 C 题爆 0 的情况下，我居然还能拿省一耶。奇怪的是好多佬只有省二。那我只能说，暴力骗分真香（）期待 6 月的国赛，同时球球不要让我拿国优。\n\n\n\n之后的计划\n\n目前我在算法和数据结构的认识上，应该已经到了入门水准（）。再往后学大概就是二分神所说的“useless algorithm”，当然往后的算法一点也不 useless。只是考虑到我现在的水平，那些东西的优先级没有那么高，写题看到了新算法积累一下就好。优先级比较高的任务是思维训练和对已掌握算法的运用，训练方式主要是打 CF 和 ATC，成效大概会体现在 CF 的 rating 上。\n\n现在的目标是从蓝名起步，到九月份打上紫名。冲冲冲。只要做到比较快的写出 A,B,C,D，应该就能“轻松”达成目标吧（",
    "tags": [
      "cp"
    ],
    "author": "unknown-author",
    "source": "tLLWtG Blog"
  }
]